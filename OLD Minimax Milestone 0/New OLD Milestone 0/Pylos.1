-- 1.) Players lose when they no longer have any spheres.


-- 2.) When one or more squares of spheres are formed on the board or at higher levels, a player can choose to stack one of his spheres on it; when it is his turn to play, he then has a choice between:
-- Taking a sphere from his reserve and placing it on the board


-- 3.) When one or more squares of spheres are formed on the board or at higher levels, a player can choose to stack one of his spheres on it; when it is his turn to play, he then has a choice between:
-- Placing a sphere from his reserve on one of the squares of the spheres


-- 4.) When one or more squares of spheres are formed on the board or at higher levels, a player can choose to stack one of his spheres on it; when it is his turn to play, he then has a choice between:
-- Moving one of his spheres already on the board and putting it on a square of spheres, but only if this move raises his sphere by one or more levels.


-- (fill up the rest of the bottom level to ensure that I can't move from one square to a different square)



-- 5.) A sphere on the board cannot be moved if it is already supporting another sphere.



-- 6.) A player who makes a square of spheres in his own colour can immediately take back NONE of his spheres and put them back in his reserve.


-- 7.) A player who makes a square of spheres in his own colour can immediately take back ONE of his spheres and put them back in his reserve.


-- 8.) A player who makes a square of spheres in his own colour can immediately take back TWO of his spheres and put them back in his reserve.


-- 9.) What if a player completes an alignment, but the alignment runs off of the edge?


-- 10.) A diagonal line is not an alignment.



-- 11a.) What if you have two alignments going into each other at the same time?

-- 11b.) (this part also tests if you play and remove a piece in the same turn) He may recover any sphere belonging to him by picking them up from any level of the pyramid - including the one which he has just placed.


-- 12.) Alignment of WW_W shouldn't work.


-- 13.) An alignment shouldn't allow you to take the other player's pieces.


-- 14.) An alignment doesn't allow you to remove a piece that supports another piece.


-- 15.) Making several squares of spheres his own colour by putting on one sphere only allows the player to withdraw one or two of his spheres.


-- 16.) A valid alignment can be:
-- 4 spheres of the same colour in line on the first level



-- 17.) A valid alignment can be:
-- 3 spheres of the same colour in line on the second level



-- 18a.) What if you make an alignment on the second level, and then remove two blocks, but removing the first one makes it so that the second block's isn't supporting the first block?

-- 18b.) What if you "take" two blocks that have the same "name"?


-- 19.) Play is over when one player has no marbles in his reserve after his move is complete.

-- 20.) A *badly formed* move is one that disobeys string formats, or that has obvious errors such as out-of-range number values.  The operator=(const std::string &) method detects badly formed moves and throws an exception when it is passed one.


-- 21.) Whitespace must appear between adjacent words (e.g. "Play at") but is not required elsewhere. 



-- 22.) Additional arbitrary whitespace may appear anywhere within the string or at its ends except inside of the words Promote, Play, from, taking, to at and and.


-- 23.) Moves with two takeback squares always list the takeback squares in increasing order, first by row, second by column.


-- 24.) The operator=(string) method for all games must check for incorrect format including garbage after the end of the move, and for out-of-bounds numerical values.


-- 25.) Check for logical errors: taking back marbles when not permitted.


-- 26.) You may find it useful is your test main to do a quick check that each movey ou enter is in the GetAllMoves list.


-- 27.) If a badly formatted Move string is presented to the operator= method, the method throws a BaseException with one of the contents below where X is the name of the game and M is the full move string.  If this happens, the method does not modify the move at all.  In other words, it either modifies the move, or throws an exception indicating a bad move string, but not both.


-- 28.) Modification of rules (or "options" as the BoardTest language calls them) is done via the CheckersDlg and PylosDlg classes, which engage the user in a dialog to adjust the parameters used by the boards to determine their value.



-- 29.) A "y" is the only acceptable "yes" answer.  It may be followed by arbitrary garbage on the reply line without error.


-- 30.) The user must enter a valid integer falling within the inclusive ranges given when you run the model program.  The integer must be on a line by itself -- trailing nonwhitespace garbage is unacceptable and geenerates an error indicating there is extra garbage on the line.


-- 31.) Pylos rules (options) comprise a weight for each marble in reserve, a weight for each step above the lowest level each a played marble rises, and a weight for each played marble that is not pinned down by other marbles. 


-- 32.) Marble weight must be between 1 and 1000 inclusive.  


-- 33.) Level weight must be nonnegative and less than marble weight.  


-- 34.) Free weight must be nonnegative, less than marble weight, and even (does 0 count as even?)


-- 35.) Pylos weight rules test

-- 36.) As a special case, if the game is over then GetValue returns winVal if first player has won and -winVal if the second player has won.

-- 37.) Two PylosBoard::Keys are equal if all squares on their represented boards have the same contents, and it's the same player's turn to move.

-- 38.) Key A is "less" than Key B if
-- A next player is lower than B's next player (black is "lower" than white")


-- 39.) Key A is "less" than Key B if
-- If both have the same next player, then: In the last cell, in level-major, row-submajor, column-minor order, at which one has a white cell and the other does not, then the one with the white cell is larger.

-- 40.) Key A is "less" than Key B if
-- If all white cells are the same, then: In the last cell, in level-major, row-submajor, column-minor order, at which one has a black cell and the other does not, then the one with a black cell is larger.

-- 41.) Moves are equal if they are the same type and have exactly the same squares.

-- 42.) Move A is less than Move B if A would fall before B in the order described under Board::GetAllMoves above


-- 43.) (showMove tests) Print the string conversion of the default move.

-- 44.) Tests of the operator=(string &) sanity checks



-- 45.) ApplyMove should not clear the current move.  A showMove call after applyMove still shows the move.


-- 46.) compareKeys tests: Note that since compareKeys requires loading a board, the command has the side effect of changing board options to those stored in boardFile.


-- 47.) setOptions tests: Whenever the static weights are changed all existing boards of the current board class must automatically reflect the change in the return of GetValue.


-- 48.) testPlay test: End the loop early and without complaint if the game reaches its end.


-- 49.) Additional Pylos string sanity checks


--50.) Even more Pylos string sanity checks


-- What if I try to continue the game after "quit"?

-- 50.) What if you try to promote a piece onto a square that uses its own (old) position as a base?


-- 51.) What if I try and promote a piece *down* a level instead of *up* a level?

-- 52.) What if I try and promote a piece, but promote it parallel?


-- 53.) PylosDlg tests


-- 54.) PylosMove comparison tests

-- 55.) PylosBoard::Key comparison tests






