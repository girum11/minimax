--1.) Board valuation test:  Ensure that kWinVal shows when a player runs out of spheres.

doMove Play at [0, 1]                
doMove Play at [0, 0]
doMove Play at [2, 1]                
doMove Play at [1, 2]
doMove Play at [0, 3]                
doMove Play at [1, 3]
doMove Play at [2, 3]                
doMove Play at [2, 2]
doMove Play at [2, 0]                
doMove Play at [0, 2]
doMove Promote from [2, 0] to [0, 2] 
doMove Promote from [0, 0] to [1, 2]
doMove Play at [0, 0]                
doMove Play at [3, 3]
doMove Play at [1, 1]

*** THIS IS THE SOURCE OF YOUR NEXT BUG ***
doMove Play at [3,2] taking [3,2] and [3,3]


showBoard
showVal
testPlay 88 5
showVal
showBoard
showVal
testPlay 88 5
showVal
showBoard
undoLastMove 1000

-- 2a.) PylosMove tests:  coverage of all the different types of moves.
-- "When one or more squares of spheres are formed on the board or at higher levels, a player can choose to stack one of his spheres on it; when it is his turn to play, he then has a choice between:"
-- Set up the sphere
doMove Play at [0,0]
doMove Play at [0,1]
doMove Play at [1,0]
doMove Play at [1,1]

-- Choice 1: Play a piece on top of the sphere
doMove Play at [0,0]
showBoard
showVal
keyMoveCount
undoLastMove 1

-- (construct black sphere)
doMove Play at [2,0]
doMove Play at [0,2]
doMove Play at [3,0]
doMove Play at [1,2]

-- Choice 2: Promote a piece
doMove Promote from [3,0] to [0,0]
showBoard
showVal
keyMoveCount
undoLastMove 1

-- (fill up the rest of the bottom level to ensure that I can't move from one square to a different square)
doMove Play at [0,3]
doMove Play at [1,3]
doMove Play at [2,1]
doMove Play at [2,2]
doMove Play at [2,3]
doMove Play at [3,1]
doMove Play at [3,2]
doMove Play at [3,3]
doMove Play at [0,0]
doMove Play at [2,0]

-- 2b.) Ensure that a sphere on the board cannot be moved if it is already supporting another sphere.
showBoard
showVal
keyMoveCount

-- 3a.) Square alignemnt tests -- code coverage.
-- "A player who makes a square of spheres in his own colour can immediately take back NONE of his spheres and put them back in his reserve."
undoLastMove 1000
doMove Play at [0,0]
doMove Play at [2,2]
doMove Play at [0,1]
doMove Play at [2,3]
doMove Play at [1,0]
doMove Play at [3,2]

doMove Play at [1,1]
showBoard
showVal
keyMoveCount
undoLastMove 1

-- 3b.) 
-- "A player who makes a square of spheres in his own colour can immediately take back ONE of his spheres and put them back in his reserve."
doMove Play at [1,1] taking [0,0]
showBoard
showVal
keyMoveCount
undoLastMove 1

-- 3c.) 
-- "A player who makes a square of spheres in his own colour can immediately take back TWO of his spheres and put them back in his reserve."
doMove Play at [1,1] taking [0,0] and [0,1]
showBoard
showVal
keyMoveCount
undoLastMove 1


-- 4a.) What if you have two alignments being created at the same time, but of different players?
undoLastMove 1000
doMove Play at [0,0]
doMove Play at [1,3]
doMove Play at [0,1]
doMove Play at [2,3]
doMove Play at [0,2]
doMove Play at [3,3]

showBoard
showVal
keyMoveCount

testPlay 7 3
showBoard
showVal
undoLastMove 3

doMove Play at [2,1]
-- 4b.) Ensure that a Spot can be played and removed in the same turn, by both players in succession.
doMove Play at [0,3] taking [0,3]
doMove Play at [0,3] taking [0,3]
doMove Play at [0,3] taking [0,3]
doMove Play at [0,3] taking [0,3]
undoLastMove 1000


--5.) Ensure that an alignment that's missing a space [e.g. WW_W] doesn't work.
-- An alignment shouldn't allow you to take the other player's pieces.
undoLastMove 1000
doMove Play at [0,0]
doMove Play at [3,0]
doMove Play at [0,1]
doMove Play at [3,1]
showBoard
undoLastMove 1000


--6a.) Creating an alignment with pieces that aren't yours shouldn't work.
undoLastMove 1000
doMove Play at [1,1]
doMove Play at [3,3]
doMove Play at [0,2]
doMove Play at [2,1]
doMove Play at [0,0]
doMove Play at [2,2]
showBoard
--6b.) An alignment shouldn't allow you to remove a piece that supports another piece, even if the piece belongs to the other player. 
doMove Play at [1,0]
doMove Play at [3,2]
doMove Play at [0,1]
doMove Play at [0,0]
doMove Play at [2,3]
doMove Play at [0,3]
showBoard



15.) Making several squares of spheres his own colour by putting on one sphere only allows the player to withdraw one or two of his spheres.
-- undoLastMove 1000
-- doMove Play at [0,1]
-- doMove Play at [1,2]
-- doMove Play at [0,2]
-- doMove Play at [1,3]
-- doMove Play at [0,3]
-- doMove Play at [2,3]
-- doMove Play at [1,0]
-- doMove Play at [3,2]
-- doMove Play at [2,0]
-- doMove Play at [3,3]
-- doMove Play at [3,0]

-- doMove Play at [2,2] taking [1,2] and [2,2] and [2,3]
-- doMove Play at [2,2] taking [1,2] and [3,3]
-- doMove Play at [0,0] taking [0,0] and [0,1] and [1,0]
-- doMove Play at [0,0] taking [3,0] and [0,3]
-- undoLastMove 1

-- showBoard
-- doMove Play at [0, 0]                          
-- undoLastMove 1
-- doMove Play at [0, 2]                         
-- undoLastMove 1
-- doMove Promote from [2, 3] to [0, 2]           
-- undoLastMove 1
-- doMove Promote from [3, 2] to [0, 2]          
-- undoLastMove 1
-- doMove Promote from [3, 3] to [0, 2]           
-- undoLastMove 1
-- doMove Play at [1, 1]                         
-- undoLastMove 1
-- doMove Play at [2, 1]                          
-- undoLastMove 1
-- doMove Play at [2, 2]                         
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 2]            
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 2] and [1, 3]
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 2] and [2, 2] 
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 2] and [2, 3]
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 2] and [3, 2] 
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 2] and [3, 3]
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 3]            
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 3] and [2, 2]
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 3] and [2, 3] 
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 3] and [3, 2]
-- undoLastMove 1
-- doMove Play at [2, 2] taking [1, 3] and [3, 3] 
-- undoLastMove 1
-- doMove Play at [2, 2] taking [2, 2]           
-- undoLastMove 1
-- doMove Play at [2, 2] taking [2, 2] and [2, 3] 
-- undoLastMove 1
-- doMove Play at [2, 2] taking [2, 2] and [3, 2]
-- undoLastMove 1
-- doMove Play at [2, 2] taking [2, 2] and [3, 3] 
-- undoLastMove 1
-- doMove Play at [2, 2] taking [2, 3]           
-- undoLastMove 1
-- doMove Play at [2, 2] taking [2, 3] and [3, 2] 
-- undoLastMove 1
-- doMove Play at [2, 2] taking [2, 3] and [3, 3]
-- undoLastMove 1
-- doMove Play at [2, 2] taking [3, 2]            
-- undoLastMove 1
-- doMove Play at [2, 2] taking [3, 2] and [3, 3]
-- undoLastMove 1
-- doMove Play at [2, 2] taking [3, 3]            
-- undoLastMove 1
-- doMove Play at [3, 1]   
-- showBoard

-- doMove Play at [0, 0]                          
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 0]           
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 0] and [0, 1] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 0] and [0, 2]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 0] and [0, 3] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 0] and [1, 0]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 0] and [2, 0] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 0] and [3, 0]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 1]            
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 1] and [0, 2]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 1] and [0, 3] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 1] and [1, 0]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 1] and [2, 0] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 1] and [3, 0]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 2]            
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 2] and [0, 3]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 2] and [1, 0] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 2] and [2, 0]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 2] and [3, 0] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 3]           
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 3] and [1, 0] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 3] and [2, 0]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [0, 3] and [3, 0] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [1, 0]           
-- undoLastMove 1
-- doMove Play at [0, 0] taking [1, 0] and [2, 0] 
-- undoLastMove 1
-- doMove Play at [0, 0] taking [1, 0] and [3, 0]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [2, 0]            
-- undoLastMove 1
-- doMove Play at [0, 0] taking [2, 0] and [3, 0]
-- undoLastMove 1
-- doMove Play at [0, 0] taking [3, 0]            
-- undoLastMove 1
-- doMove Play at [0, 2]                         
-- undoLastMove 1
-- doMove Promote from [0, 1] to [0, 2]           
-- undoLastMove 1
-- doMove Promote from [1, 0] to [0, 2]          
-- undoLastMove 1
-- doMove Promote from [2, 0] to [0, 2]           
-- undoLastMove 1
-- doMove Promote from [3, 0] to [0, 2]          
-- undoLastMove 1
-- doMove Play at [1, 1]                          
-- undoLastMove 1
-- doMove Play at [2, 1]                         
-- undoLastMove 1
-- doMove Play at [2, 2]                         
-- undoLastMove 1

16.) A valid alignment can be:
4 spheres of the same colour in line on the first level

-- *** See test 11a. ***

17.) A valid alignment can be:
3 spheres of the same colour in line on the second level
-- undoLastMove 1000
-- doMove Play at [0,0]
-- doMove Play at [0,1]
-- doMove Play at [0,2]
-- doMove Play at [0,3]
-- doMove Play at [1,0]
-- doMove Play at [1,1]
-- doMove Play at [1,2]
-- doMove Play at [1,3]
-- doMove Play at [2,0]
-- doMove Play at [2,1]
-- doMove Play at [2,2]
-- doMove Play at [2,3]
-- doMove Play at [3,0]
-- doMove Play at [3,1]
-- doMove Play at [3,2]
-- doMove Play at [3,3]

-- doMove Play at [0,0]
-- doMove Play at [2,0]
-- doMove Play at [0,1]
-- doMove Play at [2,1]

-- showBoard

-- doMove Play at [0, 2]                          
-- undoLastMove 1
-- doMove Play at [0, 2] taking [0, 0]           
-- undoLastMove 1
-- doMove Play at [0, 2] taking [0, 0] and [0, 0] 
-- undoLastMove 1
-- doMove Play at [0, 2] taking [0, 0] and [0, 1]
-- undoLastMove 1
-- doMove Play at [0, 2] taking [0, 0] and [0, 2] 
-- undoLastMove 1
-- doMove Play at [0, 2] taking [0, 0] and [1, 0]
-- undoLastMove 1
-- doMove Play at [0, 2] taking [0, 1]            
-- undoLastMove 1
-- doMove Play at [0, 2] taking [0, 1] and [0, 2]
-- undoLastMove 1
-- doMove Play at [0, 2] taking [0, 2]            
-- undoLastMove 1
-- doMove Play at [1, 0]                         
-- undoLastMove 1
-- doMove Play at [1, 1]                          
-- undoLastMove 1
-- doMove Play at [1, 2]                         
-- undoLastMove 1
-- doMove Play at [2, 2]              
-- undoLastMove 1

-- showBoard

-- doMove Play at [0,2] taking [0,2]
-- showBoard
-- doMove Play at [2,2] taking [0,0]
-- doMove Play at [2,2] taking [0,3] and [2,2]
-- doMove Play at [2,2] taking [2,2] and [0,3]
-- undoLastMove 1
-- doMove Play at [2,2] taking [2,3]



This test will be the test case where I ensure that a lack of "quit" doesn't blow up the program.



18a.) What if you make an alignment on the second level, and then remove two blocks, but removing the first one makes it so that the second block's isn't supporting the first block?
-- undoLastMove 1000
-- doMove Play at [0,0]
-- doMove Play at [0,1]
-- doMove Play at [0,2]
-- doMove Play at [0,3]
-- doMove Play at [1,0]
-- doMove Play at [1,1]
-- doMove Play at [1,2]
-- doMove Play at [1,3]
-- doMove Play at [2,0]
-- doMove Play at [2,1]
-- doMove Play at [2,2]
-- doMove Play at [2,3]
-- doMove Play at [3,0]
-- doMove Play at [3,1]
-- doMove Play at [3,2]
-- doMove Play at [3,3]

-- showBoard
-- doMove Play at [0,0]
-- doMove Play at [2,0]
-- doMove Play at [0,1]
-- doMove Play at [2,1]

18b.) What if you "take" two blocks that have the same "name"?
-- doMove Play at [0,2] taking [0,0] and [0,0]
-- doMove Play at [2,2] taking [2,2] and [3,3]
-- showBoard

19.) Play is over when one player has no marbles in his reserve after his move is complete.
-- undoLastMove 1000
-- testPlay 77 75
-- showBoard
-- testPlay 77 25
-- showBoard
-- testPlay 77 25
-- showBoard
-- testPlay 77 25
-- showBoard
-- testPlay 77 15
-- showBoard
-- testPlay 77 25
-- showBoard
-- undoLastMove 1000

20.) A *badly formed* move is one that disobeys string formats, or that has obvious errors such as out-of-range number values.  The operator=(const std::string &) method detects badly formed moves and throws an exception when it is passed one.
-- undoLastMove 1000
-- doMove Play at [0,0]
-- doMove Play at [0,1]
-- doMove Play at [0,2]
-- doMove Play at [0,3]
-- doMove Play at [1,0]
-- doMove Play at [1,1]
-- doMove Play at [1,2]
-- doMove Play at [1,3]
-- doMove Play at [2,0]
-- doMove Play at [2,1]
-- doMove Play at [2,2]
-- doMove Play at [2,3]
-- doMove Play at [3,0]
-- doMove Play at [3,1]
-- doMove Play at [3,2]
-- doMove Play at [3,3]

-- showBoard
-- doMove Play at someRandomBadInputString
-- doMove Play at [7,8]
-- doMove Play at [8,7]
-- doMove Play at [23049238047239847239847, 2]
-- doMove Play at [1, 239084289034729384723984723]
-- doMove Play at [2384723984729384723984, 29348723984729384723]
-- doMove Play at [-1, 2]
-- doMove Play at [1, -2]
-- doMove Play at [1.2, 2]
-- doMove Play at [1, 2.3]
-- doMove Play at [,]
-- doMove Play at [1,]
-- doMove Play at [,2]
-- domove Play at [1,2]
-- doMove Play at (1,2]
-- doMove Play at [1,2)
-- doMove Play at (1,2)
-- doMove Play at {1,2]
-- doMove Play at [1,2}
-- doMove Play at {1,2}
-- doMove Play at [1,@]

21.) Whitespace must appear between adjacent words (e.g. "Play at") but is not required elsewhere.  
-- doMove Playat [1,2]
-- doMove Play at[1,2]
-- undoLastMove 1

22.) Additional arbitrary whitespace may appear anywhere within the string or at its ends except inside of the words Promote, Play, from, taking, to at and and.
-- doMove    		  Play   					  at 		   [ 		 1  , 		 2			] 	
-- undoLastMove 1
-- showBoard
-- doMove Pl ay at [0, 2]      
-- doMove Pro mote from [0, 0] to [0, 2]
-- doMove Promote fr om [0, 0] to [0, 2]
-- doMove Promote fro		m [0, 0] to [0, 2]
-- doMove Promote from [0, 0] t		o [0, 2]
-- doMove Pro   mote from [0, 0] to [0, 2]

-- doMove Play at [0,0]
-- doMove Play at [2,0]
-- doMove Play at [0,1]
-- doMove Play at [2,1]
-- doMove Play at [0,2] tak	ing [0,0] and [0,1]
-- doMove Play at [0,2] taking [0,0] a		nd [0,1]
-- doMove Play at [0,2] taking [0,1] and [0,0]


23.) Moves with two takeback squares always list the takeback squares in increasing order, first by row, second by column.
-- showBoard
-- doMove Play at [0,2] taking [0,1] and [0,0]
-- doMove Play at [0,2] taking [0,2] and [0,0]
-- doMove Play at [0,2] taking [0,0] and [0,0]
-- undoLastMove 1
-- doMove Play at [0,2] taking [1,0] and [0,0]
-- doMove Play at [0,2] taking [0,2] and [0,1]

24.) The operator=(string) method for all games must check for incorrect format including garbage after the end of the move, and for out-of-bounds numerical values.
-- showBoard
-- doMove Play at [0,2] taking [0,0] and [0,2] 					
-- undoLastMove 1
-- doMove Play at [0,2] taking [0,0] and [0,2.0]
-- doMove Play at [0,2] taking [0,0] and [0,2] asdfiouas
-- doMove Play at [0,2] taking [0,0] and [0,2] sdf
-- doMove Play at [0,] taking [0,0] and [0,2] doMove Play at [0,] taking [0,0] and [0,2] 

-- *** For out-of-bounds tests, see test 20. ***


25.) Check for logical errors: taking back marbles when not permitted.
-- showBoard
-- doMove Play at [0,2] taking [0,0] and [2,2]
-- doMove Play at [0,2] taking [0,0] and [3,3]
-- doMove Play at [0,2] taking [0,0] and [2,0]

26.) You may find it useful is your test main to do a quick check that each movey ou enter is in the GetAllMoves list.

-- *** This test case is in Pylos.2

27.) If a badly formatted Move string is presented to the operator= method, the method throws a BaseException with one of the contents below where X is the name of the game and M is the full move string.  If this happens, the method does not modify the move at all.  In other words, it either modifies the move, or throws an exception indicating a bad move string, but not both.
-- showMove
-- enterMove Play at [0,2] taking [0,0] and [0,0]
-- showMove
-- enterMove Play at [0,2] taking [0,0] and [4,4]
-- showMove

28.) Modification of rules (or "options" as the BoardTest language calls them) is done via the CheckersDlg and PylosDlg classes, which engage the user in a dialog to adjust the parameters used by the boards to determine their value.
-- setOptions
-- n
-- setOptions
-- noooooooooooooooooooo
-- setOptions
-- Y
-- setOptions maybe?
-- nah

29.) A "y" is the only acceptable "yes" answer.  It may be followed by arbitrary garbage on the reply line without error.
-- setOptions pretty please????
-- yeah, sure

30.) The user must enter a valid integer falling within the inclusive ranges given when you run the model program.  The integer must be on a line by itself -- trailing nonwhitespace garbage is unacceptable and geenerates an error indicating there is extra garbage on the line.
-- 100
-- 20 6
-- 20
-- 6

-- setOptions
-- y
-- 100
-- 20
-- 6 asdf
-- 6

-- setOptions
-- y
-- 100 20 6
-- 100
-- 20
-- 6

31.) Pylos rules (options) comprise a weight for each marble in reserve, a weight for each step above the lowest level each a played marble rises, and a weight for each played marble that is not pinned down by other marbles.  
-- undoLastMove 1000
-- testPlay 99 50
-- showVal
-- testPlay 99 50
-- showVal

-- setOptions
-- y
-- 50
-- 10
-- 2

-- undoLastMove 1000
-- testPlay 99 50
-- showVal
-- testPlay 99 50
-- showVal

32.) Marble weight must be between 1 and 1000 inclusive.  
-- setOptions
-- y
-- 0
-- 1.1
-- 1001
-- -1
-- 23984723947823894
-- 100



33.) Level weight must be nonnegative and less than marble weight.  
-- 1.1
-- 1001
-- -1
-- 23984723947823894
-- 200
-- 0

34.) Free weight must be nonnegative, less than marble weight, and even (does 0 count as even?)
-- 1.1
-- 1001
-- -1
-- 23984723947823894
-- 200
-- 51
-- 2

35.) Pylos weight rules test

-- *** See Pylos.2 for this test.


36.) As a special case, if the game is over then GetValue returns winVal if first player has won and -winVal if the second player has won.
-- showVal
-- showBoard
-- testPlay 56 200
-- showVal
-- showBoard

-- undoLastMove 10000
-- testPlay 57 200
-- showVal
-- showBoard

37.) Two PylosBoard::Keys are equal if all squares on their represented boards have the same contents, and it's the same player's turn to move.
-- undoLastMove 1000
-- doMove Play at [0,0]
-- doMove Play at [1,3]
-- doMove Play at [0,1]
-- doMove Play at [2,3]
-- doMove Play at [0,2]
-- doMove Play at [3,3]
-- doMove Play at [0,3]
-- undoLastMove 1
-- doMove Play at [0,3] taking [0,0] and [0,3]
-- undoLastMove 1
-- doMove Play at [1,1]
-- undoLastMove 1
-- doMove Play at [2,1]
-- saveBoard PylosBoardIbssa0
-- compareKeys PylosBoardIbssa0
-- doMove Play at [0,3] taking [0,3]
-- compareKeys PylosBoardIbssa0
-- doMove Play at [0,3] taking [0,3]
-- compareKeys PylosBoardIbssa0
-- doMove Play at [0,3] taking [0,3]
-- compareKeys PylosBoardIbssa0
-- doMove Play at [0,3] taking [0,3]
-- compareKeys PylosBoardIbssa0

-- testPlay 8 10
-- compareKeys PylosBoardIbssa0

38.) Key A is "less" than Key B if
A next player is lower than B's next player (black is "lower" than white")
-- undoLastMove 1000
-- saveBoard PylosBoardIbssa1
-- doMove Play at [0,0]
-- compareKeys PylosBoardIbssa1
-- saveBoard PylosBoardIbssa2
-- doMove Play at [0,1]
-- compareKeys PylosBoardIbssa2


39.) Key A is "less" than Key B if
If both have the same next player, then: In the last cell, in level-major, row-submajor, column-minor order, at which one has a white cell and the other does not, then the one with the white cell is larger.
-- undoLastMove 1000
-- doMove Play at [0,0]
-- doMove Play at [0,1]
-- doMove Play at [0,2]
-- doMove Play at [0,3]
-- doMove Play at [1,0]
-- doMove Play at [1,1]
-- doMove Play at [1,2]
-- doMove Play at [1,3]
-- doMove Play at [2,0]
-- doMove Play at [2,1]
-- doMove Play at [2,2]
-- doMove Play at [2,3]
-- doMove Play at [3,0]
-- doMove Play at [3,1]
-- saveBoard PylosBoardIbssa3
-- doMove Play at [3,2]
-- compareKeys PylosBoardIbssa3
-- doMove Play at [3,3]
-- compareKeys PylosBoardIbssa3
-- doMove Play at [0,0]
-- doMove Play at [0,1]
-- doMove Play at [0,2]
-- doMove Play at [0,3]
-- doMove Play at [1,0]
-- doMove Play at [1,1]
-- doMove Play at [1,2]
-- doMove Play at [1,3]
-- doMove Play at [2,0]
-- saveBoard PylosBoardIbssa4
-- doMove Play at [2,1]
-- compareKeys PylosBoardIbssa4
-- doMove Play at [2,2]
-- compareKeys PylosBoardIbssa4
-- undoLastMove 1000
-- doMove Play at [0,0]
-- doMove Play at [0,1]
-- doMove Play at [0,2]
-- doMove Play at [0,3]
-- doMove Play at [1,0]
-- doMove Play at [1,1]
-- doMove Play at [1,2]
-- doMove Play at [1,3]
-- doMove Play at [2,0]
-- doMove Play at [2,1]
-- doMove Play at [2,2]
-- doMove Play at [2,3]
-- doMove Play at [3,0]
-- doMove Play at [3,1]
-- doMove Play at [3,2]
-- doMove Play at [3,3]



40.) Key A is "less" than Key B if
If all white cells are the same, then: In the last cell, in level-major, row-submajor, column-minor order, at which one has a black cell and the other does not, then the one with a black cell is larger.

-- *** See test 39 ***

41.) Moves are equal if they are the same type and have exactly the same squares.
-- enterMove Play at [1,1]
-- compareMove Play at [1,1]
-- compareMove Play at [0,1]
-- compareMove Play at [1,1,1]
-- compareMove Play at [    1   ,      1 			]
-- compareMove Play at [1,1] taking [1,1]
-- compareMove Play at [1,1] taking [1,1] and [1,1]
-- compareMove Promote from [1,1] to [1,1]
-- compareMove Promote from [1,1] to [2,2] taking [1,1] and [2,2]

-- enterMove Promote from [1,1] to [2,2] taking [1,1] and [2,2]
-- compareMove Promote from [1,1] to [2,2] taking [2,2] and [1,1]
-- compareMove Promote from [1,1] to [2,2] taking [1,1]

-- enterMove Play at [1,1] taking [1,1]
-- compareMove Play at [1,1]
-- compareMove Play at [1,1] taking[1,1]

42.) Move A is less than Move B if A would fall before B in the order described under Board::GetAllMoves above

-- *** See test 41 ***

43.) (showMove tests) Print the string conversion of the default move.
-- showMove
-- enterMove Play at [0,  00 ]
-- showMove
-- enterMove Play at [0000000000000000000000, 0000000000000000000]
-- enterMove Play at [8, 8]
-- showMove asdfasdfiauspoifadu
-- showMove Play at [3,2]
-- enterMove Play at [0, 1]
-- showMove

-- enterMove Play at [-1, -1]
-- showMove
-- enterMove Pass
-- showMove
-- enterMove Passs
-- showMove
-- enterMove Pass sdf
-- showMove

44.) Tests of the operator=(string &) sanity checks

-- *** See test 20 ***

45.) ApplyMove should not clear the current move.  A showMove call after applyMove still shows the move.
-- undoLastMove 200

-- enterMove Play at [4,0]
-- applyMove
-- showMove

-- enterMove Play at [2,3]
-- applyMove
-- showMove

-- undoLastMove 200
-- showMove

46.) compareKeys tests: Note that since compareKeys requires loading a board, the command has the side effect of changing board options to those stored in boardFile.
-- undoLastMove 200
-- testPlay 88 38
-- saveBoard PylosBoardIbssa5
-- compareKeys PylosBoardIbssa5
-- enterMove Play at [1,0]
-- compareKeys PylosBoardIbssa5
-- setOptions
-- y
-- 4
-- 4
-- 4
-- 2
-- compareKeys PylosBoardIbssa5

-- testPlay 8 34
-- compareKeys PylosBoardIbssa5
-- setOptions
-- y
-- 6
-- 7
-- 8
-- 2
-- compareKeys PylosBoardIbssa5
-- undoLastMove 34
-- compareKeys PylosBoardIbssa5
-- loadBoard PylosBoardIbssa4
-- compareKeys PylosBoardIbssa5

47.) setOptions tests: Whenever the static weights are changed all existing boards of the current board class must automatically reflect the change in the return of GetValue.
-- undoLastMove 100
-- testPlay 34 39
-- showVal

-- setOptions
-- y
-- 50
-- 20
-- 4

-- showVal



48.) testPlay test: End the loop early and without complaint if the game reaches its end.
-- undoLastMove 1000
-- testPlay 54 1000

49.) Additional Pylos string sanity checks
-- undoLastMove 1000                
Invalid format sanity checks
-- doMove Prom0te from [0,2] to [1,1]
-- doMove Play at [0,2] to [2,0]
-- doMove Promote at [1,2]
-- doMove Play at [1,0] to [1,2]
-- doMove Promote to [2,2]
-- doMove Play from [1,1] to [1,2] taking [2,3] and [1,2]
-- doMove Promote to [1,2] from [2,3] taking [3,2] and [3,2]
-- doMove Play at [3,2] taking [2,2] and [1,0]

50.) Even more Pylos string sanity checks
-- doMove Play at [1,
-- doMove Play at [0,0] taking [0,0
-- doMove Play at [0,0 taking [3,4
-- doMove Promote to [1,2] [2,3] [3,2] [2,2]
-- doMove Promote to [1,2] from [2,3] taking [3,1
-- doMove Play Play at [0,0]

50.) What if you try to promote a piece onto a square that uses its own (old) position as a base?
-- doMove Play at [1,1]
-- doMove Play at [1,2]
-- doMove Play at [2,1]
-- doMove Play at [2,2]
-- doMove Promote from [1,1] to [1,1]
-- doMove Promote from [2,1] to [1,1]
-- showBoard

51.) What if I try and promote a piece *down* a level instead of *up* a level?

52.) What if I try and promote a piece, but promote it parallel?


53.) PylosDlg tests


54.) PylosMove comparison tests

55.) PylosBoard::Key comparison tests











quit
