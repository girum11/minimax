--1.) Checking for the case where a King jumps around and lands back into the same spot.--2.) In a multiple jump, the jumping piece or king can change directions, jumping first in one direction and then in another direction.--15.) You cannot jump the same piece twice in the same move--13.) (when jumping pieces, you remove the jumped pieces from the board).--3.) Players alternate moves in Checkers-- 4.) The player who cannot move, because he has no pieces, or because all of his pieces are blocked, loses the game-- a.) Player can't move and loses-- b.) Player has no pieces and loses-- 5.) A piece which is not a king can move one square, diagonally, forward, as in the diagram at the right.-- 6.) A king can move one square diagonally, forward or backward.-- 7a.) A piece (piece) can only move to a vacant square.-- 7b.) A piece (king) can only move to a vacant square.-- 8a.) You can capture an opopnent's piece by jumping over it, diagonally, to the adjacent vacant square beyond it.  The three squares must be lined up (diagonally adjacent) as in the diagram at the left: your jumping piece (piece), opponent's piece (piece), empty square.-- 8b.) You can capture an opopnent's piece by jumping over it, diagonally, to the adjacent vacant square beyond it.  The three squares must be lined up (diagonally adjacent) as in the diagram at the left: your jumping piece (piece), opponent's piece (king), empty square.-- 9.) A king can jump diagonally, forward or backward.-- 10.) A piece which is not a king, can only jump diagonally forward.-- 8c.) You can capture an opopnent's piece by jumping over it, diagonally, to the adjacent vacant square beyond it.  The three squares must be lined up (diagonally adjacent) as in the diagram at the left: your jumping piece (king), opponent's piece (piece), empty square.--11.) A multiple jump must be completed, you cannot stop part way through a multiple jump.--8d.) You can capture an opopnent's piece by jumping over it, diagonally, to the adjacent vacant square beyond it.  The three squares must be lined up (diagonally adjacent) as in the diagram at the left: your jumping piece (king), opponent's piece (king), empty square.--8e.) Ensure that you can't jump over a player over the board, or into a non-empty square.-- 12.) You can only jump one piece with any given jump-- 13.) When jumping pieces, you remove jumped pieces from the board.-- 14.) You cannot jump your own piece (tested with King trying to jump own piece backwards).-- 15.) If you can jump, you must.-- 16.) A piece that has just kinged, cannot continue jumping pieces, until the next move.-- 17.) When a piece reaches the last row, it becomes a King.-- 18.) You can make only one move per turn.  You must move.-- 19.) Red [black in our case] moves first.-- 20.) Normal pieces can't move backwards-- 21.) A *badly formed* move is one that disobeys string formats, or that has obvious errors such as out-of-range number values.  The operator=(const std::string &) method detects badly formed moves and throws an exception when it is passed one.-- 22.) Must test for incorrect format including garbage after the end of the move-- 23.) "->" is surrounded optionally by blanks-- 24.) Verify that each move is in the list of GetAllMoves-- 25.) If a badly formatted Move string is presented to the operator= method, the method throws a BaseException with one of the contents below where X is the name of the game, and M is the full move string.  If this happens, the method does not modify the move at all.  In other words, it either modifies the move, or throws an exception indicating a bad move strnig, but not both.-- 26.) Modification of rules (or "options" as the BoardTest language calls them) is done via the CheckersDlg and PylosDlg classes, which engage the user in a dialog to adjust the parameters used by the boards to determine their value.-- 27.) A "y" is the only acceptable "yes" answer.  It may be followed by arbitrary garbage on the reply line without error.-- 28.) The user must enter a valid integer falling within the inclusive ranges given when you run the model program.  Checkers rules comprise a weight for the values of the kinged piece [0,1000], for the value of a of a piece on the back row [0,1000] and for having the next move [0,100].-- 29.) The integer must be on a line by itself -- trailing nonwhitespace garbage is unacceptable and generates an error indicating there is extra garbage on the line.-- 30.) Checkers weight is determined by using a weight of 100 for each piece ont he board (negative for white, who plays second) or a special king weight (again negative for white) for each king piece and each piece on a back row, plus a final added weight for which side has the move.-- 31.) As a special case, if the game is over then GetValue returns winVal if first player has won, -winVal if the second player has won.-- 32.) Two CheckersBoard::Keys are equal if all squares have same color of piece (or are both empty).-- 33.) Two CheckersBoard::Keys are equal if all squares have the same type of piece (king or nonKing).-- 34.) One square is less than another if its row is less.-- 35.) One square is less than another if its row is the same and its column is less.-- 36.) Move A is less than move B if A is a strict prefix of B.-- 37.) ApplyMove does not clear the current move.  A showMove call after applyMove still shows the move.-- 38.) compareKeys tests: Note that since compareKeys requires loading a board, the command has the side effect of changing board options to those stored in boardFile.-- 39.) Whenever the static weights are changed all existing boards of the current board class must automatically reflect the change in the return of GetValue-- 40.) testPlay test: End the loop early and without complaint if the game reaches its end.-- 41.) Check against invalid string input-- This will be the Checkers test case that ensures that a lack of a "quit" command doesn't blow the entire program up.